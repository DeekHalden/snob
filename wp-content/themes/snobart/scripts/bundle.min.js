/* Resources.js
 * This is simply an image loading utility. It eases the process of loading
 * image files so that they can be used within your game. It also includes
 * a simple "caching" layer so it will reuse cached images if you attempt
 * to load the same image multiple times.
 */
(function() {
    var resourceCache = {};
    var loading = [];
    var readyCallbacks = [];

    /* This is the publicly accessible image loading function. It accepts
     * an array of strings pointing to image files or a string for a single
     * image. It will then call our private image loading function accordingly.
     */
    function load(urlOrArr) {
        if(urlOrArr instanceof Array) {
            /* If the developer passed in an array of images
             * loop through each value and call our image
             * loader on that image file
             */
            urlOrArr.forEach(function(url) {
                _load(url);
            });
        } else {
            /* The developer did not pass an array to this function,
             * assume the value is a string and call our image loader
             * directly.
             */
            _load(urlOrArr);
        }
    }

    /* This is our private image loader function, it is
     * called by the public image loader function.
     */
    function _load(url) {
        if(resourceCache[url]) {
            /* If this URL has been previously loaded it will exist within
             * our resourceCache array. Just return that image rather
             * re-loading the image.
             */
            return resourceCache[url];
        } else {
            /* This URL has not been previously loaded and is not present
             * within our cache; we'll need to load this image.
             */
            var img = new Image();
            img.onload = function() {
                /* Once our image has properly loaded, add it to our cache
                 * so that we can simply return this image if the developer
                 * attempts to load this file in the future.
                 */
                resourceCache[url] = img;

                /* Once the image is actually loaded and properly cached,
                 * call all of the onReady() callbacks we have defined.
                 */
                if(isReady()) {
                    readyCallbacks.forEach(function(func) { func(); });
                }
            };

            /* Set the initial cache value to false, this will change when
             * the image's onload event handler is called. Finally, point
             * the image's src attribute to the passed in URL.
             */
            resourceCache[url] = false;
            img.src = url;
        }
    }

    /* This is used by developers to grab references to images they know
     * have been previously loaded. If an image is cached, this functions
     * the same as calling load() on that URL.
     */
    function get(url) {
        return resourceCache[url];
    }

    /* This function determines if all of the images that have been requested
     * for loading have in fact been properly loaded.
     */
    function isReady() {
        var ready = true;
        for(var k in resourceCache) {
            if(resourceCache.hasOwnProperty(k) &&
               !resourceCache[k]) {
                ready = false;
            }
        }
        return ready;
    }

    /* This function will add a function to the callback stack that is called
     * when all requested images are properly loaded.
     */
    function onReady(func) {
        readyCallbacks.push(func);
    }

    /* This object defines the publicly accessible functions available to
     * developers by creating a global Resources object.
     */
    window.Resources = {
        load: load,
        get: get,
        onReady: onReady,
        isReady: isReady
    };
})();

var innerWidth = window.innerWidth;
var centerX = innerWidth / 2;
var innerHeight = window.innerHeight;
var centerY = innerHeight / 2;
var diamondWidth = 275;
var diamondHeight = 275;

function randomX() {
    var result = Math.floor((Math.random() * window.innerWidth) + 1);

    return result;
};
var randomY = function() {
    return Math.floor((Math.random() * window.innerHeight) + 1)
};

var randomIntFromInterval = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

class Dot {
    constructor(x, y, xMove, yMove) {

        this.sprite = 'images/dot.png';
        this.x = x;
        this.y = y;
        this.radius = 4;
        this.speed = Math.floor(Math.random() * 5);
        this.yMove = xMove;
        this.xMove = yMove;
        this.direction = randomIntFromInterval(0, 360);
    }
    update(dt) {
        if (this.x >= innerWidth - this.radius) {
            this.x = (10 / 6) * Math.cos(this.direction) + this.speed
        }
        if (this.x <= 0 + this.radius) {
            this.xMove = !this.xMove
            this.x += 1 + (10 / 6) * Math.cos(this.direction) + this.speed
            this.y += 1 + (10 / 6) * Math.sin(this.direction) + this.speed
        }
        if (this.y >= innerHeight - this.radius) {
            this.y = (10 / 6) * Math.sin(this.direction) + this.speed
        }
        if (this.y <= 0 + this.radius) {
            this.yMove = !this.yMove
            this.x += 1 + (10 / 6) * Math.cos(this.direction) + this.speed
            this.y += 1 + (10 / 6) * Math.sin(this.direction) + this.speed
        }
    }

    moveToCursor(x, y) {
        var dx = this.x - x
        var dy = this.y - y
        var dist = Math.abs(Math.sqrt( dx * dx + dy + dy))
        console.log(dist)
    }
    render() {
        ctx.beginPath();
        ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
        if (this.xMove) {
            this.x += (10 / 6) * Math.cos(this.direction) + this.speed
        } else {
            this.x -= (10 / 6) * Math.cos(this.direction) + this.speed
        }
        if (this.yMove) {
            this.y += (10 / 6) * Math.sin(this.direction) + this.speed
        } else {
            this.y -= (10 / 6) * Math.sin(this.direction) + this.speed

        }
    }
};

class SmallDot extends Dot {
    constructor(x, y, xMove, yMove) {
        super(x, y, xMove, yMove)
        this.sprite = 'images/dot--small.png'
        this.speed = Math.floor(Math.random() * 2) + 2;
    }
    update(dt) {
        super.update(dt);
    }
    render() {
        super.render();
    }
    changeDirection(x, y) {
        var dx = (this.x + this.radius / 2) - (x + 275 / 2)
        var dy = (this.y + this.radius / 2) - (y + 275 / 2)
        var width = (this.radius + 275) / 2;
        var height = (this.radius + 275) / 2;
        var crossWidth = width * dy;
        var crossHeight = height * dx;
        var collision = 'none';
        if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
            if (crossWidth > crossHeight) {
                collision = (crossWidth > (-crossHeight)) ? 'bottom' : 'left';
            } else {
                collision = (crossWidth > -(crossHeight)) ? 'right' : 'top';
            }

        }
        if (collision === 'top') {
            this.y -= (10 / 6) * Math.sin(this.direction) + this.speed
        }
        if (collision === 'right') {
            this.x += (10 / 6) * Math.sin(this.direction) + this.speed

        }
        if (collision === 'bottom') {
            this.y += (10 / 6) * Math.sin(this.direction) + this.speed

        }
        if (collision === 'left') {
            this.x -= (10 / 6) * Math.sin(this.direction) + this.speed

        }
        return (collision);
    }

}



class Diamond {
    constructor(x, y) {
        this.sprite = 'images/big-diamond.png';
        this.x = x;
        this.y = y;
        this.angle = 45 * Math.PI / 180
        this.width = 275;
        this.height = 275;
    }
    render() {
        ctx.drawImage(Resources.get(this.sprite), this.x, this.y, this.width, this.height);
        // ctx.globalCompositeOperation = "destination-out";
        // var gradient = ctx.createLinearGradient(0, 0, diamondWidth, diamondHeight);
        // gradient.addColorStop(0, "rgba(53,54,56, 0.45)");
        // gradient.addColorStop(1, "rgba(0,0,0, 0.45)");
        // ctx.fillStyle = gradient;
        // ctx.fillRect(centerX - (diamondWidth / 2),centerY - (diamondHeight / 2), diamondWidth, diamondHeight);
        ctx.closePath();
    }
    update() {
    }
    checkCollision(x, y) {
        if ((x >= this.x && x <= this.x + 275) && (y >= this.y && y <= this.y + 275)) {
            allDots.forEach(dot => dot.moveToCursor(x, y))
            smallDots.forEach(dot => dot.moveToCursor(x, y))
        }
    }

}

var allDots = []
var smallDots = []
for (var i = 0; i < 3; i++) {
    allDots.push(new Dot(centerX, centerY - 4, Math.random() >= 0.5, Math.random() >= 0.5))
    if (i % 3 === 0) {
        smallDots.push(new SmallDot(centerX, centerY - 4, Math.random() >= 0.5, Math.random() >= 0.5))
    }
}

var diamond = new Diamond(centerX - diamondWidth / 2, centerY - diamondHeight / 2);
/* Engine.js
 * This file provides the game loop functionality (update entities and render),
 * draws the initial game board on the screen, and then calls the update and
 * render methods on your player and enemy objects (defined in your app.js).
 *
 * A game engine works by drawing the entire game screen over and over, kind of
 * like a flipbook you may have created as a kid. When your player moves across
 * the screen, it may look like just that image/character is moving or being
 * drawn but that is not the case. What's really happening is the entire "scene"
 * is being drawn over and over, presenting the illusion of animation.
 *
 * This engine is available globally via the Engine variable and it also makes
 * the canvas' context (ctx) object globally available to make writing app.js
 * a little simpler to work with.
 */
var Engine = (function(global) {
    /* Predefine the variables we'll be using within this scope,
     * create the canvas element, grab the 2D context for that canvas
     * set the canvas elements height/width and add it to the DOM.
     */
    var doc = global.document,
        win = global.window,
        canvas = doc.createElement('canvas'),
        ctx = canvas.getContext('2d'),
        lastTime,
        dateNow = new Date(),
        newNow = null;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    doc.body.appendChild(canvas);

    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    canvas.addEventListener('mousemove', function(e) {
        // var mousePos = getMousePos(canvas, e);
        var message = 'Mouse position: ' + e.clientX + ',' + e.clientY;
        smallDots.forEach(dot => {
            
            dot.changeDirection(e.clientX - 137, e.clientY - 137)
        })
        win.cancelAnimationFrame(diamond.checkCollision(e.clientX, e.clientY))
        win.cancelAnimationFrame(main)
    }, false);


    /* This function serves as the kickoff point for the game loop itself
     * and handles properly calling the update and render methods.
     */

    function main() {
        /* Get our time delta information which is required if your game
         * requires smooth animation. Because everyone's computer processes
         * instructiodns at different speeds we need a constant value that
         * would be the same for everyone (regardless of how fast their
         * computer is) - hurray time!
         */
        var now = Date.now(),
            dt = (now - lastTime) / 1000.0;
        /* Call our update/render functions, pass along the time delta to
         * our update function since it may be used for smooth animation.
         */
        render();
        update(dt);

        /* Set our lastTime variable which is used to determine the time delta
         * for the next time this function is called.
         */
        lastTime = now;

        /* Use the browser's requestAnimationFrame function to call this
         * function again as soon as the browser is able to draw another frame.
         */
        win.requestAnimationFrame(main);
        // diamond.init(ctx);

    }

    /* This function does some initial setup that should only occur once,
     * particularly setting the lastTime variable that is required for the
     * game loop.
     */
    function init() {
        reset();
        lastTime = Date.now();
        main();
    }

    /* This function is called by main (our game loop) and itself calls all
     * of the functions which may need to update entity's data. Based on how
     * you implement your collision detection (when two entities occupy the
     * same space, for instance when your character should die), you may find
     * the need to add an additional function call here. For now, we've left
     * it commented out - you may or may not want to implement this
     * functionality this way (you could just implement collision detection
     * on the entities themselves within your app.js file).
     */
    function update(dt) {
        updateEntities(dt);

    }

    /* This is called by the update function and loops through all of the
     * objects within your allEnemies array as defined in app.js and calls
     * their update() methods. It will then call the update function for your
     * player object. These update methods should focus purely on updating
     * the data/properties related to the object. Do your drawing in your
     * render methods.
     */
    function updateEntities(dt) {
        smallDots.forEach(function(dot) {
            dot.update(dt);
        })
        allDots.forEach(function(dot) {
            dot.update(dt);
        });
        diamond.update();
    }

    /* This function initially draws the "game level", it will then call
     * the renderEntities function. Remember, this function is called every
     * game tick (or loop of the game engine) because that's how games work -
     * they are flipbooks creating the illusion of animation but in reality
     * they are just drawing the entire screen over and over.
     */
    function render() {
        /* This array holds the relative URL to the image used
         * for that particular row of the game level.
         */
        // var rowImages = [
        //         'images/water-block.png',   // Top row is water
        //         'images/stone-block.png',   // Row 1 of 3 of stone
        //         'images/stone-block.png',   // Row 2 of 3 of stone
        //         'images/stone-block.png',   // Row 3 of 3 of stone
        //         'images/grass-block.png',   // Row 1 of 2 of grass
        //         'images/grass-block.png'    // Row 2 of 2 of grass
        //     ],
        //     numRows = 6,
        //     numCols = 5,
        //     row, col;

        /* Loop through the number of rows and columns we've defined above
         * and, using the rowImages array, draw the correct image for that
         * portion of the "grid"
         */
        // for (row = 0; row < numRows; row++) {
        //     for (col = 0; col < numCols; col++) {
        /* The drawImage function of the canvas' context element
         * requires 3 parameters: the image to draw, the x coordinate
         * to start drawing and the y coordinate to start drawing.
         * We're using our Resources helpers to refer to our images
         * so that we get the benefits of caching these images, since
         * we're using them over and over.
         */
        //         ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
        //     }
        // }
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        renderEntities();
    }

    /* This function is called by the render function and is called on each game
     * tick. Its purpose is to then call the render functions you have defined
     * on your enemy and player entities within app.js
     */
    function renderEntities() {
        /* Loop through all of the objects within the allEnemies array and call
         * the render function you have defined.
         */
        allDots.forEach(function(dot) {
            dot.render();
            // console.log(dot.getDate())
        });
        smallDots.forEach(function(dot) {
            dot.render();
        })

        diamond.render();


    }

    /* This function does nothing but it could have been a good place to
     * handle game reset states - maybe a new game menu or a game over screen
     * those sorts of things. It's only called once by the init() method.
     */
    function reset() {
        // noop
    }

    /* Go ahead and load all of the images we know we're going to need to
     * draw our game level. Then set init as the callback method, so that when
     * all of these images are properly loaded our game will start.
     */
    Resources.load([
        'images/big-diamond.png',
        'images/dot.png',
        'images/dot--small.png',

    ]);
    Resources.onReady(init);

    /* Assign the canvas' context object to the global variable (the window
     * object when run in a browser) so that developers can use it more easily
     * from within their app.js files.
     */
    global.ctx = ctx;
})(this);